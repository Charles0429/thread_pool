###本线程池架构和特性

首先，线程池里面分为管理线程(master_thread)和工作线程(work_thread)

其中，管理线程完成的工作主要是

- 统计工作线程池的空闲和繁忙的线程个数
- 当空闲线程大于某个比例的时候，自动减少系统中线程的个数，当系统中繁忙线程大于某个比例的时候，能自动创建新的线程

在介绍工作线程要完成的工作之前，我们先来了解一下工作线程的组成，主要是包括一个任务队列，里面可能有多个需要本工作线程处理的任务，所以，工作线程完成的工作主要是

- 当本工作线程队列中有任务需要处理时，按照队列FIFO顺序处理任务
- 当收到管理线程发出的退出信号的时候，先处理完任务队列的所有任务，然后退出

用户接口：

用户接口主要是下面的函数

    task_t *task_create(void);//创建一个任务结构体
    void task_init(task_t *t, void* (*task_callback)(void *), void *arg);//对任务初始化
    void task_add(thread_pool_t *p, task_t *t);//把任务添加到线程池中处理

在task\_add函数中，我们按照轮转的方式分别为每个线程分配任务，比如，假设当前线程池中有N个线程，编号为1-N，那么，如果这次我们把新添加到线程池中的任务分配给了线程2，那么，下个新添加的任务会分配给3，依此类推，到N后又轮转到线程1。

所以，通过上面的介绍，本线程池的特性如下：

- 每个线程池配置一个任务队列，只有在任务分配的时候才会用到全局的锁
- 可以动态的扩大和缩小线程池的容量
- 用户接口很简单，只需要写好自己的任务处理函数就可以轻松使用线程池

下面具体的介绍本线程池的一些细节

###线程池的任务分配策略

目前采用的是轮转的方法分配任务，假如线程池中目前有编号1-N的线程，有编号I-J的任务待添加到线程池中，那么线程池采用的是如下的策略：

假设I分配到线程的M的队列中，那么任务I+1会被分配到(M+1)%N+1的线程队列中，依此类推即可。

###线程池容量的动态扩大和缩小

线程池容量的动态扩大和缩小主要涉及两方面：

- 管理线程监控当前所有工作线程的负载情况
- 容量缩小的时候，工作线程配合管理线程自动退出

对于上面第一点，目前采用的是管理线程统计工作线程中繁忙和空闲的个数，然后，根据比例决定是否创建新的线程和使得一些线程退出。

对于上面第二点，工作线程在

- 任务队列不为空并且状态不为退出状态下，工作线程会一直执行任务直到任务队列为空
- 任务队列不为空并且状态为退出状态下，工作线程会一直执行任务直到任务队列为空，并且在任务队列为空的时候，会退出当前线程
- 任务队列为空并且状态不为退出，工作线程会一直睡眠，直到有新任务添加到本线程或者线程状态变成退出
- 任务队列为空并且状态为退出，工作线程则会直接退出
- 


